## 面试题

### 类
##### 1. 给定类如下：
```
class Person(Object):
    def __init__(self, parent_name, name, kids=[]):
        self.parent_name = parent_name
        self.name = name
        self.kids = []
```
- 让对象在打印时更友好点，hack \__repr__
- 让对象的属性都是不可变的，使用\__slots__
- deep_copy

### Redis
##### 1. 设置一个LRU缓存

LRU(Last Recently Used)近期最少使用算法，它的原理是缓存一定量的数据，当缓存数量超过设置的阈值时，就删除一部分旧的数据。

###### LRU缓存策略实现原理

![](./images/WechatIMG5.jpeg)

- 使用双向链表记录数据的被使用时间
  - 在缓存中唯一个双向链表，该链表按照访问时间从新到旧排列起来
  - 当需要访问一个数据时，如果缓存中已经缓存了该数据，则将该数据从缓存的双向链表中摘除，然后重新放入到双向链表的表头。
- 使用hash表保证缓存中的数据访问速度
  - 链表查找的时间复杂度为O(n)，为了提高效率，我们除了将数据维护在一个双向链表中，同时还将数据维护在一个hash表中，这时访问效率为O(1)。

### Python数据操作
##### 1. 列表原地去重

```
a = [1,2,3,4,5,6]
b = [3,4]
result = [1,2,5,6]
解决：
list(set(a) - set(b))
```

### MySQL
##### 1. 索引

- 目的

索引的目的在于提高查询效率。

- 原理

通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

- 建索引的几大原则
  - 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
  - =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
  - 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
  - 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
  - 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
- 工具
  - explain命令
- 慢查询优化的基本步骤
  - 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
  - where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
  - explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
  - order by limit 形式的sql语句让排序的表优先查
  - 了解业务方使用场景
  - 加索引时参照建索引的几大原则
  - 观察结果，不符合预期继续从0分析