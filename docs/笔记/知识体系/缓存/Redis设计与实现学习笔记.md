---
layout: blog
title: 'Redis实现原理与简单应用'
date: 2018-04-09 14:48:52
categories: 缓存
tags: git
lead_text: 'Redis实现原理与简单应用'
---

## Redis设计与实现学习笔记
### 一. 简单动态字符串

#### SDS的定义

![](./images/Redis中的SDS定义.png)

- free属性的值为0， 表示这个SDS没有分配任何未使用空间
- len属性的值为5，表示这个SDS保存了一个五字节长的字符串
- buf属性的值是一个char类型的数组，数组的前五个字节分别保存了‘R’、‘e’、‘d’、‘i’、‘s’五个字符，而最后一个字节则保存了空字符串'\0'。

#### SDS与C字符串的区别

根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符‘\0’。

##### 1. 常熟复杂度获取字符串长度

因为C字符串并不记录自身的长度信息，所以获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符串为止，这个操作的复杂度为O(N)。

SDS在len属性中记录了SDS本身的长度，获取一个SDS字符串的复杂度仅为O(1)。

##### 2. 杜绝缓冲区溢出

C语言执行strcat拼接字符串时，将src字符串中的内容拼接到dest字符串的末尾，先假设已经为dest分配了足够多的内存可以容纳src字符串中的所有内容，而一旦假设不成立时，则会产生缓冲区溢出。

与C字符串不同，SDS的空间分配策略完全杜绝了缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改需要的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS不需要手动修改SDS的空间大小。

##### 3. 减少修改字符串时带来的内存重分配次数

C语言增常或者缩短一个字符串，程序需要对保存这个字符串的数组进行一次内存重新分配：

- 如果程序执行的是增长字符串的操作，那么在执行之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作，那么在执行之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。

为了避免C字符串的缺陷，SDS实现了空间预分配和惰性空间两种优化策略。

###### 空间预分配

空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。

额外分配的未使用空间数量由以下公式决定：

- 如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。
- 如果对SDS进行修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。

###### 惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作：当SDS的SPI需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。

与此同时，SDS也提供了相应的API，可以在有需要时，真正地释放SDS的未使用空间。

##### 4. 二进制安全

C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾。这些限制了C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

SDS API都是以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样，它被读取时就是什么样。

##### 5. 兼容部分C字符串函数

虽然SDS的API是二进制安全的，但一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组未分配空间时多分配一个字节来容纳这个字符串，这就是为了让那些保存文本数据的SDS可以重用一部分<string.h>库定义的函数。

#####  6. 总结

![](./images/SDS与C字符串区别.png)

### 二. 链表

作为一种常用数据结构，链表内置于很多高级的编程语言里面，Redis使用的C语言没有内置这种数据结构，所以Redis构建了自己的链表实现。

#### 重点

- 链表被广泛应用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
- 每个链表节点由一个listNode结构体来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双向链表。
- 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现时无环链表。
- 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。

#### 链表和链表节点的实现

每个链接节点使用一个adlist.h/listNode结构来表示

![](./images/lisNode定义.png)

list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则实现多态链表所需的类型特定函数。

![](./images/list定义.png)

- dup函数用于复制链表节点所保存的值
- free函数用于释放链表节点所保存的值
- match函数用于对比链表节点所保存的值和另一个输入值是否相等

#### 总结

- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。
- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
- 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。
- 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行技术，程序获取链表中的节点数量的复杂度为O(1)。
- 多态：链表节点使用void *指针来保存节点值，并且可以使用list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。

### 三. 字典

字典，又称符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。

字典作为一种常用数据结构内置在很多高级编程语言里面，Redis使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。

#### 重点

- 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
- Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个劲在进行rehash时使用。
- 当字典被用于数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值会连接成一个单向链表。
- 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式地完成的。

### 四. 跳跃表

#### 重点

- 跳跃表时有序列表的底层实现之一
- Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，而zskiplistNode则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是1-32之间的随机数
- 在同一个跳跃表中，多个节点可以包含相同的分数，但是每个及诶蛋的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

### 五. 整数集合

#### 重点

- 整数集合是集合键的底层实现之一。
- 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
- 整数集合只支持升级操作，不支持降级操作。

### 六. 压缩列表

#### 重点

- 压缩列表是一种为节约内存而开发的顺序型数据结构。
- 压缩列表被用作列表键和哈希键的底层实现之一。
- 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
- 添加节点到压缩列表，或者从压缩列表中删除列表，可能会引发连锁更新操作，但这种操作出现的几率不高。

### 七. 对象

#### 重点

- Redis数据库中的每个键值对的键和值都是一个对象。
- Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
- Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象占用的内存就会被自动释放。
- Redis会共享值为0到9999的字符串对象
- 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

#### 对象的类型与编码

Redis使用对象来表示数据库中的键和值，每当在数据库中新建一个键值对时，至少会创建两个对象，一个对象是作键值对的键，另一个对象是作键值对的值。

##### 类型

对象的类型如下：

![](./images/Redis对象的类型.png)

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的其中一种。

TYPE命令在面对不同类型的值对象时所产生的输出：

![](./images/Redis对象类型的输出.png)

##### 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的`encoding`属性决定的。

`encoding`属性记录了对象所使用的编码，即是这个对象使用了什么数据结构作为对象的底层实现。

### 八. 数据库

#### 重点

- Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。
- 客户端通过修改目标数据库指针，让它指向redisServer.db数组中不同元素来切换不同的数据库。
- 数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。
- 因为数据库时由字典构成的，所以对数据库的操作都是建立在字典操作智商的。
- 数据可的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序列表对象，分别对应字符串键、哈希键、集合键、列表键和有序集合键。
- expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。
- Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除已经过期的键。
- 执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包括已经过期的键。
- 执行BGREWRITE命令所产生的AOF文件不会包括已经过期的键。
- 当一个过期键被删除后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。
- 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、去中心话的过期删除策略可以保证主从服务器数据的一致性。
- 当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。

### 九. RDB持久化

#### 重点

- RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。
- SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
- BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器。
- 服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。
- RDB文件是一个经过压缩的二进制文件，由多个部分组成。
- 对于不同类型的键值对，RDB文件会用不同的方式保存它们。

### 十. AOF持久化

#### 重点

- AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
- AOF文件中的所有命令都以Redis命令请求协议的格式保存。
- 命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。
- appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。
- 服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。
- AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。
- AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。
- 在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此完成AOF文件重写操作。

### 十一. 事件

#### 重点

- Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。
- 文件事件处理器是基于Reactor模式实现的网络通信程序。
- 文件事件是对套接字操作的抽象：每次套接字变为可应答、可写或者可读时，相应的文件事件就会产生。
- 文件事件分为读事件和写事件两类。
- 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。
- 服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。
- 文件事件和时间事件是合作关系，服务器会轮流处理两种事件，并且处理事件的过程中也不会进行抢占。
- 时间事件的实际处理时间通常会比设定的到达时间晚一些。

### 十二. 客户端

#### 重点

- 服务器状态结构使用clients链表连接多个客户端状态，新添加的客户端状态会被放到链表的末尾。
- 客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。
- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1G。
- 命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。
- 客户端有固定大小缓冲区和可变大小缓冲区，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。
- 当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。
- 处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。
- 载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。

### 十三. 服务器

#### 重点

- 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：
  - 初始化服务器状态
  - 载入服务器配置
  - 初始化服务器数据结构
  - 还原数据库状态
  - 执行事件循环
- 一个命令请求从发送到完成主要包括以下步骤：
  - 客户端命令请求发送给服务器
  - 服务器读取命令请求，并分析命令参数
  - 命令执行器根据参数查找命令的实现函数，然后执行实现并得出命令回复
  - 服务器将命令回复返回给客户端
- serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接受的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等

### 十四. 复制

#### 重点

- Redis 2.8以前的复制功能不能高效地处理断线后重复复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。
- 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现。
- 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行这些复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
- 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。

### 十五. Sentinel
### 十六. 集群
### 十七. 发布与订阅
### 十八. 事务
### 十九. Lua脚本
### 二十. 排序
### 二十一. 二进制位组
### 二十二. 慢查询日志
### 二十三. 监视器